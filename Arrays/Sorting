Bubble Sort:

#include <stdio.h>

int main()
{
    int a[5]={1,3,2,5,4};
    
    for(int i=0;i<5-1;i++)//n-1
    {
        for(int j=0;j<5-i-1;j++){//n-1-i
            if(a[j]>a[j+1]){
                int t=a[j];
                a[j]=a[j+1];
                a[j+1]=t;
            }
        }
    }

    
    for(int i=0;i<5;i++){
        printf("%d ",a[i]);
    }
    return 0;
}

The biggest element is pushed at last.
slower and less efficient than selection sort.
bcs the swapped element may also be again swapped...their position is confirmed till the end iteration but in case selection each iteration determines the smallest element.
Best case:  O(n)
Worst case: O(n^2)
Stability: stable



Selection Sort:

#include <stdio.h>

int main()
{
    int a[5]={1,3,2,5,4};
    
    for(int i=0;i<4;i++)
    {
        int pos=i;
        for(int j=i+1;j<5;j++){
            if(a[j]<a[pos])
                pos=j;
        }
        if(pos!=i)
        {
            int temp=a[i];
            a[i]=a[pos];
            a[pos]=temp;
        }
    }

    
    for(int i=0;i<5;i++){
        printf("%d ",a[i]);
    }
    return 0;
}

The smallest element is pushed at first.
Best case:  O(n^2)
Worst case: O(n^2)
Stability: unstable

stable condition:
if input order is maintained in output i.e the greater index must be come after smaller index after sorting in output.
eg:
elements:  1 4 6 4 3
index:     0 1 2 3 4

in selection sort:
step 1: 1 4[1] 6 4[3] 3
step 2: 1 3 6 4[3] 4[1]
step 3: 1 3 4[3] 6 4[1]
step 4: 1 3 4[3] 4[1] 6

here it can be noted that 4[3] occurs first bfr 4[1]. therefore unstable.

in bubble sort:
step 1: 1 4[1] 6 4[3] 3
step 2: 1 4[1] 4[3] 6 3
step 3: 1 4[1] 4[3] 3 6
step 4: 1 4[1] 3 4[3] 6
step 5: 1 3 4[1] 4[3] 6

here it can be noted that 4[3] occurs after 4[1]. therefore stable.


https://www.youtube.com/watch?v=X1DUh3JhLTw     //for stable vs unstable sort

